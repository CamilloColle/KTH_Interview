#Activate the installed packages necessary
library("Rcpp", lib = "/data/leuven/350/vsc35091/R/packages")
library("dada2", lib = "/data/leuven/350/vsc35091/R/packages") 
library("phyloseq", lib = "/data/leuven/350/vsc35091/R/packages") 
library("ggplot2", lib = "/data/leuven/350/vsc35091/R/packages") 
library("readr", lib = "/data/leuven/350/vsc35091/R/packages") 
library("plyr", lib = "/data/leuven/350/vsc35091/R/packages") 
library("reshape2", lib = "/data/leuven/350/vsc35091/R/packages") 
library("RColorBrewer", lib = "/data/leuven/350/vsc35091/R/packages") 
library("ggpubr", lib = "/data/leuven/350/vsc35091/R/packages") 
library("vegan", lib = "/data/leuven/350/vsc35091/R/packages")


#BiocManager::install("dada2", lib = "/data/leuven/350/vsc35091/R/packages")
#/vsc-hard-mounts/leuven-user/350/vsc35091/R/x86_64-pc-linux-gnu-library/4.2
#Direct R to the path where your sequencing files are.

setwd("/data/leuven/350/vsc35091/THESIS/R")
path <- "/data/leuven/350/vsc35091/THESIS/R/fastq"
#list.files(path)

#Next, we can define the PacBio primers so these can then be removed 
#if they are found to be present in any of the sequences.
#Define primer sequences
F27 <- "AGRGTTYGATYMTGGCTCAG"
R1492 <- "RGYTACCTTGTTACGACTT"
rc <- dada2:::rc
theme_set(theme_bw())

#Remove primers and orient reads:
fns <- sort(list.files(path, pattern=".fastq.gz", full.names = TRUE))
nops <- file.path(path, "noprimers", basename(fns))
prim <- removePrimers(fns, nops, primer.fwd=F27, primer.rev=dada2:::rc(R1492), orient=TRUE)

#We will now extract the sample names from the file names. In this command, 
#the file name into two components either side of ".hifi_" and only the first 
#component is kept. We then remove the word "demultiplex" with the sub command.
#With the sub command, the first part within the brackets shows the pattern, 
#the second part the replacement, and the third the dataset (sample.names).

#Extract sample names
sample.names <- sapply(strsplit(basename(fns), ".fastq."), `[`, 1)
sample.names <- sub("demultiplex.", "", sample.names)
sample.names

#Graphs can then be plotted to check the quality of the reads
#Plotting quality
plotQualityProfile(fns[1])

lens.fn <- lapply(nops, function(fn) nchar(getSequences(fn)))
lens <- do.call(c, lens.fn)
hist(lens, 100)

#In this case we see a sharp peak at ~1500. This means that the quality is fine.


#We now make a folder for the filtered files.
# Place filtered files in filtered/ subdirectory
filts <- file.path(path, "noprimers", "filtered", basename(fns))
track <- filterAndTrim(nops, filts, minQ=3, minLen=1000, maxLen=1600, maxN=0, rm.phix=FALSE, maxEE=2)
#The object track now shows the number of reads left after filtering
track

#Dereplicate
drp <- derepFastq(filts, verbose=TRUE)


#Estimating error rates 
err <- learnErrors(drp, errorEstimationFunction=PacBioErrfun, BAND_SIZE=32, multithread=TRUE)
plotErrors(err)

#Denoise
dada <- dada(drp, err=err, BAND_SIZE=32, multithread=TRUE, pool="pseudo", verbose=0) #check pool options

#Constructing the sequence table 
seqtab <- makeSequenceTable(dada); dim(seqtab)
row.names(seqtab)<-sample.names

dim(seqtab)
table(nchar(getSequences(seqtab)))

#Taxonomy is now assigned to the data using a naive Bayesian classifier method. At this step, whichever database required can be used. Here I have used the SILVA database as an example.
#Assign taxonomy
taxa <- assignTaxonomy(seqtab, "c:/Users/u0151402/Documents/Porcbiota/databases/silva_nr99_v138.1_wSpecies_train_set.fa.gz", multithread = TRUE)

#Chimera removal 
seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)

dim(seqtab.nochim)
dim(seqtab)
sum(seqtab.nochim)/sum(seqtab)
#This shows that a very high proportion of sequences (99%) are remaining after chimera removal. This is one indicator that sequencing quality is good.

#Saving the relevant outputs 
saveRDS(seqtab.nochim, "c:/Users/u0151402/Documents/WP1_microb_repos/objects/seqtab.nochim.RDS")
saveRDS(taxa, "c:/Users/u0151402/Documents/WP1_microb_repos/objects/taxa.RDS")
write.csv(track, "c:/Users/u0151402/Documents/WP1_microb_repos/objects/sequence.numbers.csv")

#Import files (when needed)
readRDS("c:/Users/u0151402/Documents/WP1_microb_repos/objects/seqtab.nochim.RDS") -> seqtab.nochim
readRDS("c:/Users/u0151402/Documents/WP1_microb_repos/objects/taxa.RDS") -> taxonomy 

#We will now remove the positive control from our data and any contaminants found in the negative controls.
#The names of the files generated by the sequencing company are shown below:
#  - bc1022--bc1107 - positive control (ZymoBIOMICSÂ® Microbial Community DNA standard D6305, D6306)
#  - bc1024--bc1107 - negative control 
#  - bc1022--bc1112 - positive control (second batch of sequencing)
#  - bc1024--bc1112 - negative control (second batch of sequencing)

#Extracting 'mock' (positive control) row from sequence table 
unqs.mock<-seqtab.nochim["bc1022--bc1107",]
#Drop ASVs absent in the mock
unqs.mock <- sort(unqs.mock[unqs.mock>0], decreasing=TRUE)

cat("DADA2 inferred", length(unqs.mock), "sample sequences present in the Mock community.\n")

#DADA2 found 26 sequence variants in the positive control. 


#Create a fasta file with the ASVs found in our mock:
names(unqs.mock)->mock.seqs 
length(mock.seqs)
names(mock.seqs)<-paste(">", 1:26, sep = "")
names(mock.seqs)
write.table(mock.seqs, "c:/Users/u0151402/Documents/WP1_microb_repos/objects/mock.seqs.fasta", sep = "\n", quote=F, col.names = F)

#Check contamination
#transpose seqtab
t.seqtab.nochim <-t(seqtab.nochim)
#merge seqtab and taxonomy
full.table<-merge(taxonomy, t.seqtab.nochim, by="row.names")
#save as csv
write.csv(full.table, file="c:/Users/u0151402/Documents/WP1_microb_repos/ASV.tax.table.csv")

#Open the csv file produced in Excel. Before you can view everything properly, you will need to select the first column, then go to Data > Text to Columns.
#Then you will need to select commas as a delimiter and apply it to the data. Then you will see a file of all ASVs, their sequences and their taxonomy for every sample. 
#Find the columns for the control samples. You can use the positive control (bc1005--bc1096) to check that taxonomy was correctly assigned. Once I order abundance from high to low for the positive control, I find ASVs for the following bacteria:
#  - Staphylococcus aureus
#  - Salmonella enterica
#  - Enterococcus faecalis
#  - Bacillus intestinalis 
#  - Listeria monocytogenes
#  - Pseudomonas aeruginosa 
#  - Escherichia-Shigella coli, flexneri, boydii
#  - Unclassified Limosilactobacillus 
#  These bacteria mostly match the composition of the positive control. Some differences were however found, mostly at the species level. S. aureus was also not supposed to be in the control - this could be some contamination, or perhaps a misclassification.

# We can also use this Excel file to find contaminants and remove these sequences from our dataset. Contaminants shown are:
# - Company's negative control (1007--1096): Bradyrhizobium elkanii
# - Our negative control 1 (1022--1089): Unclassified 0319-6G20 (class Oligoflexia), unclassified Acidibacter, unclassified Lachnospiraceae, unclassified Blautia
# - Our negative control 2 (1024--1089): Unclassified 0319-6G20 (class Oligoflexia), unclassified Lachnospiraceae, unclassified Limosilactonacillus, unclassified Oscillospiraceae

#We need to then remove obvious contaminants. Some of these taxa are present in very low numbers in the control but are very abundant in the samples. (E.g. unclassified Lachnospiraceae) - we will keep these in. On the other hand, taxa with very low abundance in all samples should be removed as these are likely contaminants (e.g. Bradyrhizobium elkanii).
#We should therefore remove three taxa: Bradyrhizobium elkanii, unclassified 0319-6G20 and unclassified Acidibacter.


#Copy and paste the contaminant sequences into the coding below to remove them from the data.

#Remove contaminant's sequence from seqtab.nochim and taxonomy 
seqtab.nochim<- seqtab.nochim[,-(which(colnames(seqtab.nochim)=="AGTGAACGCTGGCGGTAGGCCTAACACATGCAAGTCGAACGGCAGCACAGAGGAGCTTGCTCCTTGGGTGGCGAGTGGCGGACGGGTGAGGAATACATCGGAATCTACTCTGTCGTGGGGGATAACGTAGGGAAACTTACGCTAATACCGCATACGACCTACGGGTGAAAGCAGGGGATCTTCGGACCTTGCGCGATTGAATGAGCCGATGTCGGATTAGCTAGTTGGCGGGGTAAAGGCCCACCAAGGCGACGATCCGTAGCTGGTCTGAGAGGATGATCAGCCACACTGGAACTGAGACACGGTCCAGACTCCTACGGGAGGCAGCAGTGGGGAATATTGGACAATGGGCGCAAGCCTGATCCAGCCATACCGCGTGGGTGAAGAAGGCCTTCGGGTTGTAAAGCCCTTTTGTTGGGAAAGAAATCCAGCTGGCTAATACCCGGTTGGGATGACGGTACCCAAAGAATAAGCACCGGCTAACTTCGTGCCAGCAGCCGCGGTAATACGAAGGGTGCAAGCGTTACTCGGAATTACTGGGCGTAAAGCGTGCGTAGGTGGTCGTTTAAGTCCGTTGTGAAAGCCCTGGGCTCAACCTGGGAACTGCAGTGGATACTGGACGACTAGAGTGTGGTAGAGGGTAGCGGAATTCCTGGTGTAGCAGTGAAATGCGTAGAGATCAGGAGGAACATCCATGGCGAAGGCAGCTACCTGGACCAACACTGACACTGAGGCACGAAAGCGTGGGGAGCAAACAGGATTAGATACCCTGGTAGTCCACGCCCTAAACGATGCGAACTGGATGTTGGGTGCAATTTGGCACGCAGTATCGAAGCTAACGCGTTAAGTTCGCCGCCTGGGGAGTACGGTCGCAAGACTGAAACTCAAAGGAATTGACGGGGGCCCGCACAAGCGGTGGAGTATGTGGTTTAATTCGATGCAACGCGAAGAACCTTACCTGGCCTTGACATGTCGAGAACTTTCCAGAGATGGATGGGTGCCTTCGGGAACTCGAACACAGGTGCTGCATGGCTGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGTCCTTAGTTGCCAGCACGTAATGGTGGGAACTCTAAGGAGACCGCCGGTGACAAACCGGAGGAAGGTGGGGATGACGTCAAGTCATCATGGCCCTTACGGCCAGGGCTACACACGTACTACAATGGTAGGGACAGAGGGCTGCAAGCCGGCGACGGTAAGCCAATCCCAGAAACCCTATCTCAGTCCGGATTGGAGTCTGCAACTCGACTCCATGAAGTCGGAATCGCTAGTAATCGCAGATCAGCATTGCTGCGGTGAATACGTTCCCGGGCCTTGTACACACCGCCCGTCACACCATGGGAGTTGTTGCACCAGAAGCAGGTAGCTTAACCTTCGGGAGGGCGCTTGCCACGGTGTGGCCGATGACTGGGGTG"))]


taxonomy<-taxonomy[-(which(row.names(taxonomy)=="AGTGAACGCTGGCGGTAGGCCTAACACATGCAAGTCGAACGGCAGCACAGAGGAGCTTGCTCCTTGGGTGGCGAGTGGCGGACGGGTGAGGAATACATCGGAATCTACTCTGTCGTGGGGGATAACGTAGGGAAACTTACGCTAATACCGCATACGACCTACGGGTGAAAGCAGGGGATCTTCGGACCTTGCGCGATTGAATGAGCCGATGTCGGATTAGCTAGTTGGCGGGGTAAAGGCCCACCAAGGCGACGATCCGTAGCTGGTCTGAGAGGATGATCAGCCACACTGGAACTGAGACACGGTCCAGACTCCTACGGGAGGCAGCAGTGGGGAATATTGGACAATGGGCGCAAGCCTGATCCAGCCATACCGCGTGGGTGAAGAAGGCCTTCGGGTTGTAAAGCCCTTTTGTTGGGAAAGAAATCCAGCTGGCTAATACCCGGTTGGGATGACGGTACCCAAAGAATAAGCACCGGCTAACTTCGTGCCAGCAGCCGCGGTAATACGAAGGGTGCAAGCGTTACTCGGAATTACTGGGCGTAAAGCGTGCGTAGGTGGTCGTTTAAGTCCGTTGTGAAAGCCCTGGGCTCAACCTGGGAACTGCAGTGGATACTGGACGACTAGAGTGTGGTAGAGGGTAGCGGAATTCCTGGTGTAGCAGTGAAATGCGTAGAGATCAGGAGGAACATCCATGGCGAAGGCAGCTACCTGGACCAACACTGACACTGAGGCACGAAAGCGTGGGGAGCAAACAGGATTAGATACCCTGGTAGTCCACGCCCTAAACGATGCGAACTGGATGTTGGGTGCAATTTGGCACGCAGTATCGAAGCTAACGCGTTAAGTTCGCCGCCTGGGGAGTACGGTCGCAAGACTGAAACTCAAAGGAATTGACGGGGGCCCGCACAAGCGGTGGAGTATGTGGTTTAATTCGATGCAACGCGAAGAACCTTACCTGGCCTTGACATGTCGAGAACTTTCCAGAGATGGATGGGTGCCTTCGGGAACTCGAACACAGGTGCTGCATGGCTGTCGTCAGCTCGTGTCGTGAGATGTTGGGTTAAGTCCCGCAACGAGCGCAACCCTTGTCCTTAGTTGCCAGCACGTAATGGTGGGAACTCTAAGGAGACCGCCGGTGACAAACCGGAGGAAGGTGGGGATGACGTCAAGTCATCATGGCCCTTACGGCCAGGGCTACACACGTACTACAATGGTAGGGACAGAGGGCTGCAAGCCGGCGACGGTAAGCCAATCCCAGAAACCCTATCTCAGTCCGGATTGGAGTCTGCAACTCGACTCCATGAAGTCGGAATCGCTAGTAATCGCAGATCAGCATTGCTGCGGTGAATACGTTCCCGGGCCTTGTACACACCGCCCGTCACACCATGGGAGTTGTTGCACCAGAAGCAGGTAGCTTAACCTTCGGGAGGGCGCTTGCCACGGTGTGGCCGATGACTGGGGTG")),]

#Remove controls from seqtab.nochim
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1024---bc1107")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1022---bc1107")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1024--bc1112")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1022--bc1112")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1008--bc1112")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1012--bc1112")),]

seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1005--bc1105")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1007--bc1105")),]

seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1005--bc1107")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1022--bc1105")),]
seqtab.nochim<- seqtab.nochim[-(which(rownames(seqtab.nochim)=="bc1024--bc1105")),]


#Check how many columns and rows there are in the data 
dim(seqtab.nochim)
dim(taxonomy)
dim(design_new)

#There are further additional steps to check the quality of the data such as plotting rarefaction. First however, the data have to be converted into a 'phyloseq' object. This phyloseq object can also be used for simple taxonomy plots and for showing alpha diversity.
#To create the phyloseq object, the file showing all of the metadata/parameters is needed.
#Before importing this file, add the name that was generated by the sequencing company in Excel. I have done this in a column called 'barcode'. 
#Import design
design<-read.csv("c:/Users/u0151402/Documents/WP1_microb_repos/design_V2.csv", header = TRUE, sep = ";", fileEncoding = 'UTF-8-BOM')
design<-read.delim("c:/Users/u0151402/Documents/WP1_microb_repos/design_two.txt")

names_not_in_design<-sample.names[!(sample.names %in% design$Barcode)]
print(names_not_in_design)

design<-design[1:58,]

design_new<-design[design$sample != "bc1024---bc1107",]
design_new<-design_new[design_new$sample != "bc1022---bc1107", ]
design_new<-design_new[design_new$sample != "bc1024--bc1112", ]
design_new<-design_new[design_new$sample != "bc1022--bc1112", ]
design_new<-design_new[design_new$sample != "bc1008--bc1112", ]
design_new<-design_new[design_new$sample != "bc1012--bc1112", ]
design_new<-design_new[design_new$Location != "08AT", ]

design_new<-merge(clusters, design_new, by="sample")
row.names(design_new)<-design_new$sample

colnames(design)[colnames(design) == "Barcode"] <- "sample"

#Check format 
design<-as.data.frame(design)
#Phyloseq requires the sample names to be stored in the row.names of the design table
row.names(design)<-design$Barcode

#Create a phyloseq object
ps<-phyloseq(otu_table(seqtab.nochim, taxa_are_rows=F), tax_table(taxonomy),
             sample_data(design_new))


#Checking distribution of sequence depth 
sample_sum_df <- data.frame(sum = sample_sums(ps))
ggplot(sample_sum_df, aes(x = sum)) +
  geom_histogram(color = "black", fill = "indianred", binwidth = 500
  )+
  ggtitle("Distribution of sample sequencing depth") + xlab("Read counts") +
  ylab("Number of samples")
sort(sample_sums(ps))

#Rarefaction
#Define the function to calculate the rarefaction curve
calculate_rarefaction_curves <- function(psdata, measures, depths) { require('plyr')
  require('reshape2')
  estimate_rarified_richness <- function(psdata, measures, depth) { if(max(sample_sums(psdata)) < depth) return()
    psdata <- prune_samples(sample_sums(psdata) >= depth, psdata)
    rarified_psdata <- rarefy_even_depth(psdata, depth, verbose = FALSE)
    alpha_diversity <- estimate_richness(rarified_psdata, measures = measures)
    molten_alpha_diversity <- melt(as.matrix(alpha_diversity), varnames = c('Sample', 'Measure'), value.name = 'Alpha_diversity')
    molten_alpha_diversity
  }
  names(depths) <- depths
  rarefaction_curve_data <- ldply(depths, estimate_rarified_richness , psdata = psdata, measures = measures, .id = 'Depth', .progress = ifelse(interactive(), 'text', 'none'))
  rarefaction_curve_data$Depth <- as.numeric(levels(rarefaction_curve_data$Depth))[rarefaction_curve_data$Depth]
  rarefaction_curve_data
}
#Apply to data 
rarefaction_curve_data <- calculate_rarefaction_curves(ps, c('Observed', 'Shannon'), rep(seq(from=10, to= 50000, by=500), each = 10))

#If you would prefer other alpha-diversity parameters, just add their name.

#Adjust data before plotting 
rarefaction_curve_data$Sample<-gsub(pattern="X", replacement="", x=rarefaction_curve_data$Sample) 
rarefaction_curve_data$Sample<-gsub(pattern="\\.", replacement="-", x=rarefaction_curve_data$Sample)
rarefaction_curve_data_summary <- ddply(rarefaction_curve_data, c('Depth', 'Sample', 'Measure'), summarise, Alpha_diversity_mean = mean(Alpha_diversity), Alpha_diversity_sd = sd(Alpha_diversity))
rarefaction_curve_data_summary_verbose <- merge(rarefaction_curve_data_summary, data.frame(sample_data(ps)), by.x = 'Sample', by.y = 'row.names')

#Plot
ggplot(
  data = rarefaction_curve_data_summary_verbose, mapping = aes(
    x = Depth,
    y = Alpha_diversity_mean,
    ymin = Alpha_diversity_mean - Alpha_diversity_sd, ymax = Alpha_diversity_mean + Alpha_diversity_sd, colour = Location,
    group = Sample,
    label= Sample
  )
) + geom_line( ) + facet_wrap(
  facets = ~ Measure,
  scales = 'free_y'
) + ggsave("c:/Users/u0151402/Documents/WP1_microb_repos/pictures/rarefaction.png", dpi=300,height = 100, width = 130, units = "mm")

saveRDS(ps, "c:/Users/u0151402/Documents/WP1_microb_repos/objects/ps.RDS")

#This rarefaction plot shows sequencing depth. If the curve reaches its asymptote and plateaus, then it means that the full depth was achieved. If however, the curve is still increasing, it means that all the diversity has probably not been captured in the depth sequenced.
#Samples that haven't plateaued should therefore be removed. In this case, all samples have a good sequencing depth.

#Taxonomy can be plotted using the phyloseq object. These plots are quick for a quick overview, although for more detailed manipulation, there is limited flexibility. 

##Plotting taxonomy 
#Agglomerate sequence counts by Genus
ps_glom<-tax_glom(ps, taxrank = "Genus")
#Transform counts to proportions
ps_prop = transform_sample_counts(ps_glom, function(x) x / sum(x) )
#Remove genera whose abundance is below 0.5% of the total sequences
ps_prop = filter_taxa(ps_prop, function(x) sum(x) > 0.5, TRUE)

#Make a plot where the colour of bars represent the genus
#The 15 in mypalette(15) represents the number of colours needed for the plot
colorRampPalette(brewer.pal(12,"Paired"))->mypalette
plot_bar(ps_prop, fill="Genus")+
  scale_fill_manual(values = mypalette(15))

as.data.frame(otu_table(ps_prop))->otus


#Next, we will use a different package to plot taxonomy. In doing this, we will also produce tables showing taxonomic abundance. For this, the 'seqtab.nochim' file must again be used.

#Transpose seqtab.nochim and make it show abundance as proportions
t.seqtab.nochim<-as.data.frame(t(seqtab.nochim))
t.seqtab.nochim<-as.data.frame(prop.table(as.matrix(t.seqtab.nochim), margin=2))
#All columns should therefore add up to 1. The colSums function can be used to check.
colSums(t.seqtab.nochim)

#create one single table from taxonomy and sequence variant table
taxtab<-merge(taxonomy, t.seqtab.nochim, by="row.names")
#For tables, when you want to get rid of a column, you need to use '<-NULL'...
taxtab$Row.names<-NULL

#Replace the NAs in the table with unclassified_something
taxtab$Kingdom<-NULL #(Only use if the table also has kingdom)
taxtab$Phylum<-as.character(taxtab$Phylum)
taxtab$Class<-as.character(taxtab$Class)
taxtab$Order<-as.character(taxtab$Order)
taxtab$Family<-as.character(taxtab$Family)
taxtab$Genus<-as.character(taxtab$Genus)
taxtab$Species<-as.character(taxtab$Species)

taxtab$Phylum[which(is.na(taxtab$Phylum))]<-"unclassified bacterium"

#For the next part, taxonomy is examined at the genus level. To look at other levels you will need to change the column number and the name Genus in the following coding to suit what you want to examine.
#The function below is the one which replaces the NAs. You therefore need to apply it to all columns after phylum. So, if you just have up to the genus level, 2:5, or 2:6 to include species too.
for(x in (2:5)){
  newname<-paste("unclassified",as.character(taxtab[is.na(taxtab[,x]),x-1]))
  taxtab[is.na(taxtab[,x]) , x] <- newname
}

taxtab[,2:5]<-apply(taxtab[,2:5], MARGIN = 2, function(y)  gsub("unclassified unclassified", "unclassified", y))

#At the moment, taxtab is unaggregated so it shows all ASVs that were found rather than just all species. You might like to save it as this stage for future use before we merge all ASVs according to species.
unaggregated.taxtab<-taxtab
saveRDS(unaggregated.taxtab, "c:/Users/u0151402/Documents/WP1_microb_repos/objects/unaggregated.taxtab.RDS")

#Aggregate the table by genus
myfun<- function(x) {if (class(x)%in%c("numeric", "integer")) {sum(x)} 
  else {if (length(unique(x))==1) {x[1]}
    else {NA}}}

taxtab<-aggregate(taxtab, by=list(taxtab$Genus), FUN=myfun)

#Simplify the table keeping only the genus information
genus.tab<-taxtab[, 6:ncol(taxtab)]
row.names(genus.tab)<-taxtab$Genus

#At this stage, you can also remove any unnecessary columns. We no longer need genus or species for instance, as the genus is now the row name of the table.
genus.tab$Genus<-NULL
genus.tab$Species<-NULL

#Order taxa by mean abundance
genus.tab<-genus.tab[order(rowMeans(genus.tab), decreasing = T),]

colSums(genus.tab)

#We now group together genera under a certain threshold as an 'other' category. In this case, those genera with an overall mean abundance of less than 1%. To change this, just change the number in the first two lines of the coding below, and the under_1% label.
#Group together genera under 1% mean representation and check
genus.short<-genus.tab[rowMeans(genus.tab)>=0.0075,]
others<-colSums(genus.tab[rowMeans(genus.tab)<0.0075, ])
genus.short[nrow(genus.short)+1,]<-others
row.names(genus.short)[nrow(genus.short)]<-"under_0.75%"
colSums(genus.short)

#Put genus names in a column
genus.short$genus<-row.names(genus.short)

#Transform the table to a long format
library(tidyr)
genus.long<-gather(genus.short, key = sample, value = Proportion, -genus)

#Order the genera in the same way they were ordered in the previous table (by abundance)
genus.long$genus<-factor(genus.long$genus, levels = genus.short$genus)

#The design file will now be merged with the genus.long file. For the 'by = ' parameter, type the column name you want to use to merge the two tables. In this case, sample. 
#First, rename the barcode column in the design table to just be called sample.
names(design)[4] <- "sample"
#Now we can merge the design table with genus.long. 
final.tab<-merge(design_new, genus.long, by="sample")
final.tab.io<-merge(design_in_old, genus.long, by="sample")

#Set a colour scheme
library(RColorBrewer)
#'If you want to choose a different colour palette, you can search for the R colour palette names on the internet. You can also manually select the colours you need if this is necessary, although of course this takes a bit longer.
colorRampPalette(brewer.pal(12,"Paired"))->mypalette

#Plot (without faceting)
library(ggplot2)
ggplot(final.tab, aes(x=sample, y=Proportion, fill=genus))+
  geom_bar(stat="identity", color="white")+
  scale_fill_manual(values = mypalette(length(unique(final.tab$genus))))+
  theme(text = element_text(size=15), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  guides(fill=guide_legend(ncol=4))

#If you need to divide samples by groups on the graph, you can use faceting. In this example for instance, I will use faceting to divide samples by hatching system.
#The ggsave command can also be used to automatically save the graph. You may get an error when running with ggsave, but it should still work. (Just check in your documents that it has saved).

ggplot(final.tab, aes(x=Subject, y=Proportion, fill=genus))+
  geom_bar(stat="identity", color="white")+
  scale_fill_manual(values = mypalette(length(unique(final.tab$genus))))+
  theme(text = element_text(size=13), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  facet_grid( ~ enterotype,  space="free", scales = "free")+
  guides(fill=guide_legend(ncol=3)+
           ggsave(file = "c:/Users/u0151402/Documents/WP1_microb_repos/pictures/bar.plot.enterotypes.png", dpi=300, height = 200, width=370, units = "mm"))



#We can then repeat this for other parameters e.g. bodyweight.

ggplot(final.tab, aes(x=sample, y=Proportion, fill=genus))+
  geom_bar(stat="identity", color="white")+
  scale_fill_manual(values = mypalette(length(unique(final.tab$genus))))+
  theme(text = element_text(size=13), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  facet_grid( ~ Sow,  space="free", scales = "free")+
  guides(fill=guide_legend(ncol=3)+
           ggsave(file = "c:/Users/u0151402/Documents/WP1_storage_trial/pictures/bar.plot.sow.png", dpi=300, height = 200, width=320, units = "mm"))


#The annotated code below shows a breakdown of what each section does so you can change these parameters to change the appearance of your graphs if needed.

#ggplot(final.tab, aes(x=patient, y=Proportion, fill=genus))+ #set the table where to take the data from (final.tab) set x and y axis, and color fill legend. "fill" is the inside of bars

#geom_bar(stat="identity", color="white")+ #set the type of plot and the color of bar borders ("color" is the edge of the bars)

#scale_fill_manual(values = mypalette(length(unique(final.tab$genus))))+ #set colors for filling. In this case I chose a palette from RColorBrewer (see above "set my favourite colours"). To use the palette, you need to state how many colors you need. In this case I do that with length(unique(final.tab$genus)) which is equal to the number of different values taken by the variable "genus" in the table "final.tab"

#theme(text = element_text(size=9), # size of all text
#axis.title.x = element_text(size = 9),
#axis.text.x = element_text(angle = 90), # You can specify size, oriantation, color and other parameters of each text bit in the plot. Other text parameters to use in the same way are "axis.title.y", "axis.text.y", "strip.text.x", "strip.text.y" ( strip=text in the facets)

#legend.position = "bottom", # position of legend, can be "left", "right", "top".

#legend.title = element_blank())+  # legend title. I use element_blank when I want to get rid of it.

#facet_grid(type_of_sample ~ birth, space="free", scales = "free")+ # facets. Structure is "variable on y" ~ "variable on x". You can use a single variable putting a dot (e.g. .~birth, or birth~.)

#guides(fill=guide_legend(ncol=3))+ # number of columns for the legend

#ggtitle("Genus bar plot")+ #title of the plot

#xlab("Patient")+ #title of x axis, if different from the variable name

#ylab("Relative abundance")+##title of y axis, if different from the variable name

#ggsave("c:/Users/u0151402/Documents/MGH/pictures/bar.plot.type.png", dpi=300, height = 200, width=320, units = "mm") #save with dimensions. If you don't specify the dimensions, you will get a plot in the same dimensions as the window where it is displayed in rstudio. Enlarging or changing the shape of a plot can be useful to fit in all the elements. The bigger the plot is, the smaller the text will look, so a strategy to enlarge all the text is to make the plot smaller! To veryfy the effect of your changes open the file, you won't see them in the RStudio window.

################################################################################
##ALPHA DIVERSITY

#The plot_richness package offers several alpha diversity indices to choose from. These are: Observed, Chao1, ACE, Shannon, Simpson, InvSimpson and Fisher.

#Generic richness plot. A column for each sample.
plot_richness(ps, measures = c("Observed", "Shannon"))

#samples grouped according to type_of_sample variable
plot_richness(ps, x= "sample", measures = "Shannon")

#Add boxplots

palette <- c("#BBF5DF", "#F7D1C2")

plot_richness(ps_in_old, x= "Bedding.material", measures = c("Chao1", "Shannon"))+
  geom_boxplot()+
  stat_compare_means(method = "kruskal.test")

plot_richness(ps_in_old, x= "Slatted.floor", measures = c("Shannon", "Chao1"))+
  geom_boxplot(aes(fill=sample_data(ps_in_old)))+
  scale_fill_manual(values = palette)
stat_compare_means(method = "kruskal.test")

plot_richness(ps, x= "Breed.subspecies", measures = "Shannon")+
  geom_boxplot()+
  stat_compare_means(method = "kruskal.test")
#################################################################################
##BETA DIVERSITY


#Log transformation
ps@sam_data$enterotype<-as.character(ps@sam_data$enterotype)
ps_log <- transform_sample_counts(ps, function(x) log(1+x))

#'To plot a PCoA of the data the argument "MDS" (multi-dimensional scaling) is used. Other measures can be used instead to plot different graphs if required, e.g. NMDS.
#'The argument "bray" is the default distance method (Bray-Curtis). If necessary, this can also be changed. There are many alternatives e.g. unifrac, jsd (Jensen-Shannon divergence), jaccard etc.

#PCoA
pcoa<-ordinate(ps_log, "MDS", "bray" )
plot_ordination(ps_log, pcoa, type="sample", color= "", shape = "Species..English.", label = "Subject")+
  geom_point(size = 3)

plot_ordination(ps_log, pcoa, type="sample", color= "enterotype", shape = "enterotype", label = "Subject")+
  geom_point(size = 3)
#The geom_point function can be used to change the size of the dots on the graph. Or if desired, the shapes/colours of points can also be changed.

#Finally, to determine statistical significance, a PERMANOVA test can be performed. You will need to check that you use the same distance measures as for the PCoA, e.g. bray in this case.
#PERMANOVA
#extract from phyloseq the tables
seqtab_log<-as(otu_table(ps_log), "matrix")
taxonomy_log<-as(tax_table(ps_log), "matrix")
design_log<-as(sample_data(ps_log), "data.frame")
#dissimilarity matrix
dist.bray<-vegdist(seqtab_log, method = "bray")
#define variable
groups <- as.factor(design_log$Organic.standard)
levels(groups)
# PERMANOVA test
adonis2(dist.bray ~ groups, design_log, permutations = 9999)

#library(MicEco)
per<-adonis2(dist.bray ~ groups, design_log, permutations = 9999)
adonis_OmegaSq(per, partial = TRUE)

#In this case, PERMANOVA yields a p-value of 0.0045. So in terms of beta-diversity there is a significant difference based on groups. Other parameters can be tested by changing the variable as shown below. For hatching system for instance, there is no significant difference in beta-diversity.

groups <- as.factor(design_log$Sow)
levels(groups)
# PERMANOVA test
adonis2(dist.bray ~ groups, design_log, permutations = 9999)


###Phylogenetic tree
library(ape)

phylotree<-rtree(ntaxa(ps), rooted = TRUE, tip.label = taxa_names(ps))
plot(phylotree)

ps.unif<-phyloseq(otu_table(seqtab.nochim, taxa_are_rows=F), tax_table(taxonomy),
                  sample_data(design), phy_tree(phylotree))

ps_log_unif <- transform_sample_counts(ps.unif, function(x) log(1+x))

pcoa.unif<-ordinate(ps_log_unif, "MDS", "unifrac", weighted=TRUE)
plot_ordination(ps_log_unif, pcoa.unif, type="sample", color= "Location", shape = "Species..English.", label = "Subject")+
  geom_point(size = 3)

################################################################################
#We will now do tests to determine whether certain factors are associated with different microbiota traits, e.g. the presence of a certain genus.For this, we will need to use a taxonomic abundance table, with metadata columns from the design file added on.

#Transpose genus.tab
genus.met<-as.data.frame(t(genus.tab))
#Create a new column for sample
genus.met$sample<-row.names(genus.met)
genus.met <- merge(design_new, genus.met, by = "sample")


#Add row names
row.names(genus.met)<-genus.met$sample
#Remove any unwanted columns
genus.met$sample<-NULL
genus.met$Sample<-NULL


#These columns have to be made factors. (Not so important in this case, but important if metadata are numbers)
genus.met$enterotype<-as.factor(genus.met$enterotype)
genus.met$Bodyweight<-as.factor(genus.met$Bodyweight)

#We will now use the Kruskal-Wallis test to see if Lactobacillus is significantly associated with bodyweight.
library(tidyverse)
kruskal.test(genus.met$Lactobacillus ~ genus.met$enterotype)

#Now that we know that Lactobacillus is significantly associated with bodyweight, we can plot a boxplot to show the abundance of Lactobacillus for different groups.
ggplot(genus.met, aes(x=Soil.present, y=`Holdemanella`, fill=Soil.present))+
  geom_boxplot()+
  theme(text = element_text(size=15), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  stat_compare_means()+
  geom_jitter(color="black", size=0.4, alpha=0.9)+
  xlab("Soil present?")+
  ggsave("c:/Users/u0151402/Documents/WP1_microb_repos/pictures/box.plot.crop.condition.Lactobacillus.png", dpi=300, height = 200, width=320, units = "mm")

ggplot(genus.met, aes(x=factor(Inside.outside, level = c("Inside", "Both", "Outside")), y=`Lactobacillus`, fill=Inside.outside))+
  geom_boxplot()+
  theme(text = element_text(size=15), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  stat_compare_means()+
  geom_jitter(color="black", size=0.4, alpha=0.9)+
  xlab("Inside/Outside")+
  ggsave("c:/Users/u0151402/Documents/WP1_microb_repos/pictures/box.plot.crop.condition.Lactobacillus.png", dpi=300, height = 200, width=320, units = "mm")



ggplot(genus.met, aes(x=Location, y=`Cellulosilyticum`, fill=Location))+
  geom_boxplot()+
  theme(text = element_text(size=15), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  stat_compare_means()+
  geom_jitter(color="black", size=0.4, alpha=0.9)+
  xlab("Condition")+
  scale_fill_discrete(labels=c('Planckendael Zoo', 'Merelbeke', 'TRANSfarm', 'CRA-W', 'CIA'))+
  ggsave("c:/Users/u0151402/Documents/WP1_microb_repos/pictures/box.plot.location.Cellulosilyticum.png", dpi=300, height = 200, width=320, units = "mm")


#To save time, we can test for all samples simultaneously. 
#Note that when doing these tests, we apply Bonferroni correction to take into account the number of taxa, which produces a very stringent p-value.

#Test for all samples 
library(tibble)
results<-data_frame(Genus=character(length = ncol(genus.met)-1),
                    kruskal_p=numeric(length = ncol(genus.met)-1))

for (i in 59:ncol(genus.met)){
  results[i-1,1]<-colnames(genus.met)[i]
  kruskal.test(genus.met[,i]~genus.met$enterotype)->res
  results[i-1,2]<-res$p.value
}
results<-results[(results$Genus=="")==F,]
sig.results<-results[results$kruskal_p< 0.05/(nrow(results)-1),]
View(results)
View(sig.results)

#Although with the stringent p-value there were no significant results, you can still open the results and order genera by the smallest value which shows 8 under 0.05.

#Plot boxplots for other genera...
ggplot(genus.met, aes(x=enterotype, y=`Bacteroides`, fill=enterotype))+
  geom_boxplot()+
  theme(text = element_text(size=15), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  stat_compare_means()+
  geom_jitter(color="black", size=0.4, alpha=0.9)+
  xlab("Enterotype")+
  ggsave("c:/Users/u0151402/Documents/WP1_storage_trial/pictures/box.plot.crop.condition.Phascolarctobacterium.png", dpi=300, height = 200, width=320, units = "mm")


#Here is how to perform ANOVA if you want to use this instead:
anova<-aov(Lactobacillus ~ Bodyweight, genus.met)
summary(anova)

ggplot(genus.met, aes(x=Bodyweight, y=Lactobacillus, fill=Bodyweight))+
  geom_boxplot()+
  theme(text = element_text(size=15), legend.position = "bottom", axis.text.x = element_text(angle = 90))+
  stat_compare_means(method = "anova")+
  geom_jitter(color="black", size=0.4, alpha=0.9)+
  xlab("Bodyweight")


#Now we will create tables to show the mean abundances and standard deviation for the four different bodyweight groups.
#Farm high
#Keep only farm high samples in the table
genus.fh<-as.data.frame(t(genus.met[,2:ncol(genus.met)]))
genus.fh<-genus.fh[,grep("Farm High", genus.fh)]
#Remove the first row with bodyweight
genus.fh<-genus.fh[2:nrow(genus.fh),]
#Create a column for means
genus.fh[] <- lapply(genus.fh, as.numeric)
genus.fh$mean<-rowMeans(genus.fh)
#Standard deviation for all rows except the means (column 11)
library(matrixStats)
genus.fh$sd<-rowSds(as.matrix(genus.fh[,1:10]))

#Farm low
#Keep only farm low samples in the table
genus.fl<-as.data.frame(t(genus.met[,2:ncol(genus.met)]))
genus.fl<-genus.fl[,grep("Farm Low", genus.fl)]
#Remove the first row with bodyweight
genus.fl<-genus.fl[2:nrow(genus.fl),]
#Create a column for means
genus.fl[] <- lapply(genus.fl, as.numeric)
genus.fl$mean<-rowMeans(genus.fl)
#Standard deviation for all rows except the means (column 10)
genus.fl$sd<-rowSds(as.matrix(genus.fl[,1:9]))
